# Standard Input, Output and Error

As we are starting to grapple with some simple programs, we want these programs to be interactive. Here we get introduced to our standard IO buffers, `stdin`, `stdout` and `stderr`. However, within C#, we will normally access these through a method like `Read`, `ReadLine`,`Write`, `WriteLine` or `Error.WriteLine`.

## Input and Output

We will focus on input and output buffers right now. Let's take a look at simple outputting data to the shell. When interacting with `stdout`, we will use the method `Console.WriteLine` or `Console.Write`. Both of these methods will be interpreting your data that you have inputted into it and printing it out to the screen. To achieve this, it must be able to convert it to a string.
Lets start with a simple sample.

```cs
string name = "Jeff";

Console.WriteLine(name);
```

The above snippet will accept the argument `name` which is assigned to the value `"Jeff"`. The `WriteLine` method will then write this to the terminal. There is very little processing or translation it will need to do.

However, what if we do the following?

```cs
int n = 10;

Console.WriteLine(n);
```

Now we can observe that the value `10` is printed to the screen but `WriteLine` would needed to have converted it to a `string`. Now, since `Console.WriteLine` has a way to handle `int` data, it will likely convert each digit to the relevant `ASCII` digit.

Refer to the following table [ASCII Table](https://en.wikipedia.org/wiki/ASCII#Printable_character_table) and you'll notice that our integer would need to be translated to `0x6160`, where `61` is `1` and `60` is `0`.


To start handling data that the user can input, you will typically interact with reading `stdin` by using `Console.Read` or `Console.ReadLine`. These will return a character (read) or a string (readline).

Lets dig into `ReadLine`, since `ReadLine` returns a string, we are able to reasily assign it to a string variable.

```cs
string line = Console.ReadLine();

// Do something with the Line
Console.WriteLine(line);
```

We can observe that we have a simple `echo` program where whatever we type in, the program will repeat back out to us. How about we jazz it up a bit by adding `**` around it.


```cs
string line = Console.ReadLine();

Console.WriteLine("**" + line + "**");
```

The above snippet will add `**` around the line being read. It is still an echo program but now it is doing a little more.

### What if I want to convert data?

This is a common issue and something where if you refer to section 3.3, you will discover the conversion methods to do so. If we can convert data to a string, we are able to convert it back, assuming it has a pattern that can be followed.


## `stderr`/Console.Error

While it isn't common to use this buffer, it is valuable when implementing/leveraging error handling or immediately flushing the data to the shell.

When using `Console.Error`, you'll likely discover that it has simile functionality to `Console.WriteLine` and `Console.Write`, making it seem somewhat meaningless.

However, what is not obvious is that `Console.WriteLine` and `Console.Write` do not print to the screen **immediately**. `Console.Error.*` will satisfy this constraint and it also allows you have fine-control over the buffers when using the program as well.

As an example, if we have a program that contains the following snippet.

```cs
Console.WriteLine("This is a line to be outputted");
```

We were to run it like so.

```
dotnet run > program.output
```

We will observe that the string is not outputted to the shell however has been written to `program.output`. However, by leverage `Console.Error` we can print to the terminal and also redirect output that we may want to **log**.


```cs
Console.WriteLine("This is a line to be outputted to the file");
Console.Error.WriteLine("This is a line to be outputted to the shell");
```
You will observe the `program.output` file holding the data from `WriteLine` but not `Error.WriteLine`.
